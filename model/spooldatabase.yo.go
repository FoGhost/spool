// Code generated by yo. DO NOT EDIT.
// Package model contains the types.
package model

import (
	"context"
	"fmt"
	"time"

	"cloud.google.com/go/spanner"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
)

// SpoolDatabase represents a row from 'SpoolDatabases'.
type SpoolDatabase struct {
	DatabaseName string    `spanner:"DatabaseName" json:"DatabaseName"` // DatabaseName
	Checksum     string    `spanner:"Checksum" json:"Checksum"`         // Checksum
	State        int64     `spanner:"State" json:"State"`               // State
	CreatedAt    time.Time `spanner:"CreatedAt" json:"CreatedAt"`       // CreatedAt
	UpdatedAt    time.Time `spanner:"UpdatedAt" json:"UpdatedAt"`       // UpdatedAt
}

func SpoolDatabasePrimaryKeys() []string {
	return []string{
		"DatabaseName",
	}
}

func SpoolDatabaseColumns() []string {
	return []string{
		"DatabaseName",
		"Checksum",
		"State",
		"CreatedAt",
		"UpdatedAt",
	}
}

func (sd *SpoolDatabase) columnsToPtrs(cols []string, customPtrs map[string]interface{}) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		if val, ok := customPtrs[col]; ok {
			ret = append(ret, val)
			continue
		}

		switch col {
		case "DatabaseName":
			ret = append(ret, &sd.DatabaseName)
		case "Checksum":
			ret = append(ret, &sd.Checksum)
		case "State":
			ret = append(ret, &sd.State)
		case "CreatedAt":
			ret = append(ret, &sd.CreatedAt)
		case "UpdatedAt":
			ret = append(ret, &sd.UpdatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}
	return ret, nil
}

func (sd *SpoolDatabase) columnsToValues(cols []string) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		switch col {
		case "DatabaseName":
			ret = append(ret, sd.DatabaseName)
		case "Checksum":
			ret = append(ret, sd.Checksum)
		case "State":
			ret = append(ret, sd.State)
		case "CreatedAt":
			ret = append(ret, sd.CreatedAt)
		case "UpdatedAt":
			ret = append(ret, sd.UpdatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}

	return ret, nil
}

// newSpoolDatabase_Decoder returns a decoder which reads a row from *spanner.Row
// into SpoolDatabase. The decoder is not goroutine-safe. Don't use it concurrently.
func newSpoolDatabase_Decoder(cols []string) func(*spanner.Row) (*SpoolDatabase, error) {
	customPtrs := map[string]interface{}{}

	return func(row *spanner.Row) (*SpoolDatabase, error) {
		var sd SpoolDatabase
		ptrs, err := sd.columnsToPtrs(cols, customPtrs)
		if err != nil {
			return nil, err
		}

		if err := row.Columns(ptrs...); err != nil {
			return nil, err
		}

		return &sd, nil
	}
}

// Insert returns a Mutation to insert a row into a table. If the row already
// exists, the write or transaction fails.
func (sd *SpoolDatabase) Insert(ctx context.Context) *spanner.Mutation {
	return spanner.Insert("SpoolDatabases", SpoolDatabaseColumns(), []interface{}{
		sd.DatabaseName, sd.Checksum, sd.State, sd.CreatedAt, sd.UpdatedAt,
	})
}

// Update returns a Mutation to update a row in a table. If the row does not
// already exist, the write or transaction fails.
func (sd *SpoolDatabase) Update(ctx context.Context) *spanner.Mutation {
	return spanner.Update("SpoolDatabases", SpoolDatabaseColumns(), []interface{}{
		sd.DatabaseName, sd.Checksum, sd.State, sd.CreatedAt, sd.UpdatedAt,
	})
}

// InsertOrUpdate returns a Mutation to insert a row into a table. If the row
// already exists, it updates it instead. Any column values not explicitly
// written are preserved.
func (sd *SpoolDatabase) InsertOrUpdate(ctx context.Context) *spanner.Mutation {
	return spanner.InsertOrUpdate("SpoolDatabases", SpoolDatabaseColumns(), []interface{}{
		sd.DatabaseName, sd.Checksum, sd.State, sd.CreatedAt, sd.UpdatedAt,
	})
}

// UpdateColumns returns a Mutation to update specified columns of a row in a table.
func (sd *SpoolDatabase) UpdateColumns(ctx context.Context, cols ...string) (*spanner.Mutation, error) {
	// add primary keys to columns to update by primary keys
	colsWithPKeys := append(cols, SpoolDatabasePrimaryKeys()...)

	values, err := sd.columnsToValues(colsWithPKeys)
	if err != nil {
		return nil, newErrorWithCode(codes.InvalidArgument, "SpoolDatabase.UpdateColumns", "SpoolDatabases", err)
	}

	return spanner.Update("SpoolDatabases", colsWithPKeys, values), nil
}

// FindSpoolDatabase gets a SpoolDatabase by primary key
func FindSpoolDatabase(ctx context.Context, db YORODB, databaseName string) (*SpoolDatabase, error) {
	key := spanner.Key{databaseName}
	row, err := db.ReadRow(ctx, "SpoolDatabases", key, SpoolDatabaseColumns())
	if err != nil {
		return nil, newError("FindSpoolDatabase", "SpoolDatabases", err)
	}

	decoder := newSpoolDatabase_Decoder(SpoolDatabaseColumns())
	sd, err := decoder(row)
	if err != nil {
		return nil, newErrorWithCode(codes.Internal, "FindSpoolDatabase", "SpoolDatabases", err)
	}

	return sd, nil
}

// Delete deletes the SpoolDatabase from the database.
func (sd *SpoolDatabase) Delete(ctx context.Context) *spanner.Mutation {
	values, _ := sd.columnsToValues(SpoolDatabasePrimaryKeys())
	return spanner.Delete("SpoolDatabases", spanner.Key(values))
}

// FindSpoolDatabasesByChecksumState retrieves multiple rows from 'SpoolDatabases' as a slice of SpoolDatabase.
//
// Generated from index 'SpoolDatabasesByChecksumAndState'.
func FindSpoolDatabasesByChecksumState(ctx context.Context, db YORODB, checksum string, state int64) ([]*SpoolDatabase, error) {
	const sqlstr = `SELECT ` +
		`DatabaseName, Checksum, State, CreatedAt, UpdatedAt ` +
		`FROM SpoolDatabases@{FORCE_INDEX=SpoolDatabasesByChecksumAndState} ` +
		`WHERE Checksum = @param0 AND State = @param1`

	stmt := spanner.NewStatement(sqlstr)
	stmt.Params["param0"] = checksum
	stmt.Params["param1"] = state

	decoder := newSpoolDatabase_Decoder(SpoolDatabaseColumns())

	// run query
	YOLog(ctx, sqlstr, checksum, state)
	iter := db.Query(ctx, stmt)
	defer iter.Stop()

	// load results
	res := []*SpoolDatabase{}
	for {
		row, err := iter.Next()
		if err != nil {
			if err == iterator.Done {
				break
			}
			return nil, newError("FindSpoolDatabasesByChecksumState", "SpoolDatabases", err)
		}

		sd, err := decoder(row)
		if err != nil {
			return nil, newErrorWithCode(codes.Internal, "FindSpoolDatabasesByChecksumState", "SpoolDatabases", err)
		}

		res = append(res, sd)
	}

	return res, nil
}
